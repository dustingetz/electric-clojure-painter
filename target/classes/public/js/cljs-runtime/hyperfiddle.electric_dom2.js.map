{"version":3,"sources":["hyperfiddle/electric_dom2.cljc"],"mappings":"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","names":["hyperfiddle.electric-dom2/nil-subject","!","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","hyperfiddle.electric-dom2/unsupported","seq47892","self__5755__auto__","cljs.core/seq","_","cljs.core.ex_info","hyperfiddle.electric-dom2/hook","x","y","hyperfiddle.electric-dom2/by-id","id","js/document.getElementById","hyperfiddle.electric-dom2/new-node","parent","type","el","G__47893","cljs.core/Keyword","js/document","goog.dom/createTextNode","goog.dom/createElement","hyperfiddle.electric-dom2/hide-on-unmount","node","missionary.core/observe","hyperfiddle.electric-dom2/-googDomSetTextContentNoWarn","str","goog.dom/setTextContent","hyperfiddle.electric-dom2/class-str","v","cljs.core/name","clojure.string.join","cljs.core.eduction","cljs.core.remove","cljs.core/nil?","cljs.core.map","hyperfiddle.electric-dom2/set-property!","k","cljs.core/clj->js","and__5043__auto__","G__47894","goog.style/setStyle","temp__5802__auto__","hyperfiddle.electric_dom2.goog$module$goog$object.get","goog.dom/DIRECT_ATTRIBUTE_MAP_","hyperfiddle.electric_dom2.goog$module$goog$object.containsKey","hyperfiddle.electric_dom2.goog$module$goog$object.set","hyperfiddle.electric-dom2/unmount-prop","G__47898","hyperfiddle.electric-dom2/event*","js/Error","dom-node","event-name","callback","hyperfiddle.electric_dom2.event_STAR_","options","hyperfiddle.electric-dom2/happen","s","e","G__47899","unused__11925__auto__","self__","G__47901","args47900","cljs.core/aclone","this__5330__auto__","writer__5331__auto__","opt__5332__auto__","cljs.core/-write","hyperfiddle.electric-dom2/Clock","hyperfiddle.electric-dom2/->Clock","raf","terminator","js/window","hyperfiddle.electric-dom2/<clock","n","t","cancel","hyperfiddle.electric-dom2/-get-system-time-ms","js/Date.now","hyperfiddle.electric-dom2/set-val"],"sourcesContent":["(ns hyperfiddle.electric-dom2\n  (:refer-clojure :exclude [time])\n  (:require #?(:cljs goog.dom)\n            #?(:cljs goog.object)\n            #?(:cljs goog.style)\n            [hyperfiddle.electric :as e]\n            [missionary.core :as m])\n  (:import [hyperfiddle.electric Pending])\n  #?(:cljs (:require-macros [hyperfiddle.electric-dom2 :refer [with]])))\n\n(e/def node)\n(def nil-subject (fn [!] (! nil) #()))\n(e/def keepalive (new (m/observe nil-subject)))\n\n(defn unsupported [& _]\n  (throw (ex-info (str \"Not available on this peer.\") {})))\n\n(def hook \"See `with`\"\n  #?(:clj  unsupported\n     :cljs (fn ([x] (.removeChild (.-parentNode x) x)) ; unmount\n             ([x y] (.insertBefore (.-parentNode x) x y))))) ; rotate siblings\n\n(defmacro with\n  \"Attach `body` to a dom node, which will be moved in the DOM when body moves in the DAG.\n  Given p/for semantics, `body` can only move sideways or be cancelled. If body is cancelled,\n  the node will be unmounted. If body moves, the node will rotate with its siblings.\"\n  [dom-node & body]\n  `(binding [node ~dom-node]\n     ; wrap body in a constant frame, so it can be moved as a block\n     (new (e/hook hook node (e/fn [] keepalive ~@body)))))\n\n#?(:cljs (defn by-id [id] (js/document.getElementById id)))\n\n#?(:cljs\n   (defn new-node [parent type]\n     (let [el (case type\n                :comment (.createComment js/document \"\")\n                :text (goog.dom/createTextNode \"\")\n                (goog.dom/createElement type))]\n       (.appendChild parent el)\n       el)))\n\n(defn hide-on-unmount [node]\n  (m/observe (fn [!]\n               (! nil)\n               #(set! (.. node -style -display) \"none\"))))\n\n(defmacro element [t & body]\n  `(with (new-node node ~(name t))\n     (new (hide-on-unmount node))\n     ~@body))\n\n#?(:cljs (defn -googDomSetTextContentNoWarn [node str]\n           ; Electric says :infer-warning Cannot infer target type in expression, fixme\n           (goog.dom/setTextContent node str)))\n\n(defmacro text [& strs]\n  `(do (assert (not= (.-nodeType node) (.-TEXT_NODE node))\n               \"userland directed dom/text inside dom/text, which is illegal\")\n       ~@(map (fn [str]\n                `(with (new-node node :text)\n                   (-googDomSetTextContentNoWarn node ~str)))\n           strs)))\n\n(defmacro comment_ [& strs]\n  (cons `do\n    (map (fn [str] `(with (new-node node :comment)\n                      (-googDomSetTextContentNoWarn node ~str)))\n      strs)))\n\n(defn class-str [v]\n  (cond\n    (or (string? v) (keyword? v)) (name v)\n    (seq v) (clojure.string/join \" \" (eduction (remove nil?) (map name) v))\n    :else \"\"))\n\n#?(:cljs\n   (defn set-property! [node k v]\n     (let [k (name k)\n           v (clj->js v)]\n       (if (and (nil? v) (.hasAttribute node k))\n         (.removeAttribute node k)\n         (case k\n           \"style\" (goog.style/setStyle node v)\n           \"class\" (set! (.-className node) (class-str v))\n           \"for\"   (set! (.-htmlFor node) v)\n           \"list\"  (.setAttribute node k v) ; corner case, list (datalist) is setted by attribute and readonly as a prop.\n           (if-let [k (goog.object/get goog.dom/DIRECT_ATTRIBUTE_MAP_ k)]\n             (.setAttribute node k v)\n             (if (goog.object/containsKey node k) ; is there an object property for this key?\n               (goog.object/set node k v)\n               (.setAttribute node k v))))))))\n\n#?(:cljs (defn unmount-prop [node k v]\n           (m/observe (fn [!] (! nil) #(set-property! node k v)))))\n\n(defmacro style [m]\n  (if (map? m)\n    `(do ~@(mapcat (fn [[k v]] [`(set-property! node \"style\" {~k ~v})\n                                `(new (unmount-prop node \"style\" {~k nil}))]) m)\n         nil) ; static keyset\n    `(e/for-by first [sty# (vec ~m)]\n       (set-property! node \"style\" {(key sty#) (val sty#)})\n       (new (unmount-prop node {(key sty#) nil}))\n       nil)))\n\n;; TODO JS runtimes intern litteral strings, so call `name` on keywords at\n;; macroexpension.\n(defmacro props [m]\n  (let [style? #{:style ::style}]       ; TODO disambiguate\n    (if (map? m)\n      `(do ~@(mapcat (fn [[k v]] (if (style? k) ; static keyset\n                                   [`(style ~v)]\n                                   [`(set-property! node ~k ~v)\n                                    `(new (unmount-prop node ~k nil))]))\n                     m)\n           nil)\n      `(e/for-by key [prop# (vec ~m)]\n         (if (~style? (key prop#))\n           (style (val prop#))\n           (do (set-property! node (key prop#) (val prop#))\n               (new (unmount-prop node (key prop#) nil))\n               nil))))))\n\n(defn event*\n  ([dom-node event-name callback] (event* dom-node event-name callback {}))\n  ([dom-node event-name callback options]\n   (m/observe (fn [!]\n                (! nil)\n                (.addEventListener dom-node event-name callback #?(:cljs (clj->js options)))\n                #(.removeEventListener dom-node event-name callback)))))\n\n(defmacro on!\n  \"Call the `callback` clojure function on event.\n   (on! \\\"click\\\" (fn [event] ...)) \"\n  ([event-name callback] `(new (event* node ~event-name ~callback)))\n  ([dom-node event-name callback] `(new (event* ~dom-node ~event-name ~callback)))\n  ([dom-node event-name callback options] `(new (event* ~dom-node ~event-name ~callback ~options))))\n\n(defmacro ^:deprecated ^:no-doc event \"Deprecated, please use `on!`\" [& args] `(on! ~@args))\n\n(defn happen [s e]\n  ; Todo, we need a buffer to force a nil in between events to fix race\n  (case (:status s)\n    :idle {:status :impulse :event e} ; rising edge\n    :pending {:status :impulse :event e} ; supersede the outstanding event with a new event\n    :impulse (assert false \"two events in the same frame? that's weird and wrong\")))\n\n; data EventState = Idle | Impulse event | Pending event\n(e/defn Event [type busy]\n  (:event\n    (let [!state (atom {:status :idle})\n          state (e/watch !state)]\n\n      ; rising edge happens once, even if busy state (prevent infinite loop) -- [DJG] I don't understand\n      (event type (partial swap! !state happen)) ; discrete rising edge\n\n      (reset! !state\n              (case (:status state)\n                :idle state\n                :impulse (assoc state :status :pending) ; impulse is seen for 1 frame and then cleared\n                :pending (if busy state {:status :idle}))))))\n\n#?(:cljs\n   (deftype Clock [^:mutable ^number raf\n                   ^:mutable callback\n                   terminator]\n     IFn                                                    ; cancel\n     (-invoke [_]\n       (if (zero? raf)\n         (set! callback nil)\n         (do (.cancelAnimationFrame js/window raf)\n             (terminator))))\n     IDeref                                                 ; sample\n     (-deref [_]\n       ; lazy clock, only resets once sampled\n       (if (nil? callback)\n         (terminator)\n         (set! raf (.requestAnimationFrame js/window callback))) ; RAF not called until first sampling\n       ::tick)))\n\n#?(:cljs (def ^:no-doc <clock \"lazy & efficient logical clock that schedules no work unless sampled\"\n           (fn [n t]\n             (let [cancel (->Clock 0 nil t)]\n               (set! (.-callback cancel)\n                     (fn [_] (set! (.-raf cancel) 0) (n)))\n               (n) cancel))))\n\n(defn -get-system-time-ms [_] #?(:clj (System/currentTimeMillis) :cljs (js/Date.now)))\n(e/def system-time-ms \"ms since 1970 Jan 1\" (new (m/sample -get-system-time-ms <clock)))\n(e/def system-time-secs \"seconds since 1970 Jan 1\" (/ system-time-ms 1000.0))\n\n(defmacro on\n  \"Run the given electric function on event.\n  (on \\\"click\\\" (e/fn [event] ...))\"\n  ;; TODO add support of event options (see `event*`)\n  ([typ]   `(new Event ~typ false))\n  ([typ F] `(on node ~typ ~F))\n  ([node typ F] `(binding [node ~node]\n                   (let [x# (e/with-cycle [?v# nil]\n                              (let [busy# (= ?v# ::e/pending)]\n                                (when-some [evt# (new Event ~typ busy#)]\n                                  (try (new ~F evt#)\n                                       (catch Pending e# ::e/pending)\n                                       (catch :default e# [::err e#])))))]\n                     (cond (= ::e/pending x#) (throw (Pending.))\n                           (and (vector? x#) (= ::err (first x#))) (throw (second x#))\n                           :else x#)))))\n\n(defmacro on-pending [pending-body & body] `(try (do ~@body) (catch Pending e# ~pending-body (throw e#))))\n\n(e/defn Focused? []\n  (e/with-cycle [focused false]\n    (if focused (nil? (on \"blur\")) (some? (on \"focus\")))))\n\n#?(:cljs (defn set-val [node v] (set! (.-value node) (str v))))\n\n(defmacro bind-value\n  ([v]        `(bind-value ~v set-val))\n  ([v setter] `(let [v# ~v]\n                 (when-not (new Focused?)\n                   (~setter node v#)))))\n\n(defmacro a [& body] `(element :a ~@body))\n(defmacro abbr [& body] `(element :abbr ~@body))\n(defmacro address [& body] `(element :address ~@body))\n(defmacro area [& body] `(element :area ~@body))\n(defmacro article [& body] `(element :article ~@body))\n(defmacro aside [& body] `(element :aside ~@body))\n(defmacro audio [& body] `(element :audio ~@body))\n(defmacro b [& body] `(element :b ~@body))\n(defmacro bdi [& body] `(element :bdi ~@body))\n(defmacro bdo [& body] `(element :bdo ~@body))\n(defmacro blockquote [& body] `(element :blockquote ~@body))\n(defmacro br [& body] `(element :br ~@body))\n(defmacro button [& body] `(element :button ~@body))\n(defmacro canvas [& body] `(element :canvas ~@body))\n(defmacro cite [& body] `(element :cite ~@body))\n(defmacro code [& body] `(element :code ~@body))\n(defmacro data [& body] `(element :data ~@body))\n(defmacro datalist [& body] `(element :datalist ~@body))\n(defmacro del [& body] `(element :del ~@body))\n(defmacro details [& body] `(element :details ~@body))\n(defmacro dfn [& body] `(element :dfn ~@body))\n(defmacro dialog [& body] `(element :dialog ~@body))\n(defmacro div [& body] `(element :div ~@body))\n(defmacro dl \"The <dl> HTML element represents a description list. The element encloses a list of groups of terms (specified using the <dt> element) and descriptions (provided by <dd> elements). Common uses for this element are to implement a glossary or to display metadata (a list of key-value pairs).\" [& body] `(element :dl ~@body))\n(defmacro dt \"The <dt> HTML element specifies a term in a description or definition list, and as such must be used inside a <dl> element. It is usually followed by a <dd> element; however, multiple <dt> elements in a row indicate several terms that are all defined by the immediate next <dd> element.\" [& body] `(element :dt ~@body))\n(defmacro dd \"The <dd> HTML element provides the description, definition, or value for the preceding term (<dt>) in a description list (<dl>).\" [& body] `(element :dd ~@body))\n(defmacro em [& body] `(element :em ~@body))\n(defmacro embed [& body] `(element :embed ~@body))\n(defmacro fieldset [& body] `(element :fieldset ~@body))\n(defmacro figure [& body] `(element :figure ~@body))\n(defmacro footer [& body] `(element :footer ~@body))\n(defmacro form [& body] `(element :form ~@body))\n(defmacro h1 [& body] `(element :h1 ~@body))\n(defmacro h2 [& body] `(element :h2 ~@body))\n(defmacro h3 [& body] `(element :h3 ~@body))\n(defmacro h4 [& body] `(element :h4 ~@body))\n(defmacro h5 [& body] `(element :h5 ~@body))\n(defmacro h6 [& body] `(element :h6 ~@body))\n(defmacro header [& body] `(element :header ~@body))\n(defmacro hgroup [& body] `(element :hgroup ~@body))\n(defmacro hr [& body] `(element :hr ~@body))\n(defmacro i [& body] `(element :i ~@body))\n(defmacro iframe [& body] `(element :iframe ~@body))\n(defmacro img [& body] `(element :img ~@body))\n(defmacro input [& body] `(element :input ~@body))\n(defmacro ins [& body] `(element :ins ~@body))\n(defmacro kbd [& body] `(element :kbd ~@body))\n(defmacro label [& body] `(element :label ~@body))\n(defmacro legend [& body] `(element :legend ~@body))\n(defmacro li [& body] `(element :li ~@body))\n(defmacro link [& body] `(element :link ~@body))\n(defmacro main [& body] `(element :main ~@body))\n#_(defmacro map [& body] `(element :map ~@body))\n(defmacro mark [& body] `(element :mark ~@body))\n(defmacro math [& body] `(element :math ~@body))\n(defmacro menu [& body] `(element :menu ~@body))\n(defmacro itemprop [& body] `(element :itemprop ~@body))\n(defmacro meter [& body] `(element :meter ~@body))\n(defmacro nav [& body] `(element :nav ~@body))\n(defmacro noscript [& body] `(element :noscript ~@body))\n(defmacro object [& body] `(element :object ~@body))\n(defmacro ol [& body] `(element :ol ~@body))\n(defmacro option [& body] `(element :option ~@body))\n(defmacro output [& body] `(element :output ~@body))\n(defmacro p [& body] `(element :p ~@body))\n(defmacro picture [& body] `(element :picture ~@body))\n(defmacro pre [& body] `(element :pre ~@body))\n(defmacro progress [& body] `(element :progress ~@body))\n(defmacro q [& body] `(element :q ~@body))\n(defmacro ruby [& body] `(element :ruby ~@body))\n(defmacro s [& body] `(element :s ~@body))\n(defmacro samp [& body] `(element :samp ~@body))\n(defmacro script [& body] `(element :script ~@body))\n(defmacro section [& body] `(element :section ~@body))\n(defmacro select [& body] `(element :select ~@body))\n(defmacro slot [& body] `(element :slot ~@body))\n(defmacro small [& body] `(element :small ~@body))\n(defmacro span [& body] `(element :span ~@body))\n(defmacro strong [& body] `(element :strong ~@body))\n(defmacro sub [& body] `(element :sub ~@body))\n(defmacro sup [& body] `(element :sup ~@body))\n(defmacro table [& body] `(element :table ~@body))\n(defmacro tbody [& body] `(element :tbody ~@body))\n(defmacro td [& body] `(element :td ~@body))\n(defmacro th [& body] `(element :th ~@body))\n(defmacro thead [& body] `(element :thead ~@body))\n(defmacro tr [& body] `(element :tr ~@body))\n(defmacro template [& body] `(element :template ~@body))\n(defmacro textarea [& body] `(element :textarea ~@body))\n(defmacro time [& body] `(element :time ~@body))\n(defmacro u [& body] `(element :u ~@body))\n(defmacro ul [& body] `(element :ul ~@body))\n(defmacro var [& body] `(element :var ~@body))\n(defmacro video [& body] `(element :video ~@body))\n(defmacro wbr [& body] `(element :wbr ~@body))\n"]}